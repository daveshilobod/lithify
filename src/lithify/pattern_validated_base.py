# src/lithify/pattern_validated_base.py
"""Base class for models with patternProperties validation."""

from __future__ import annotations

# Template string for code generation (like FROZENDICT_SOURCE)
# This source code will be written to generated packages
PATTERN_VALIDATED_BASE_SOURCE = '''"""
Base class for models with patternProperties validation.

Implements JSON Schema patternProperties semantics:
- Fields matching ANY pattern must validate against ALL matching patterns (AND)
- Fields not matching any pattern are rejected
- Inherits from FrozenModel to preserve immutability

Auto-generated by Lithify. Do not edit directly.
"""

from __future__ import annotations

import re
from typing import Any, ClassVar

from pydantic import model_validator, ValidationError
from pydantic_core import InitErrorDetails

from .frozen_base import FrozenModel, _deep_freeze


class PatternValidatedModel(FrozenModel):
    """
    Base for models with JSON Schema patternProperties.

    Subclasses define __pattern_properties__ with compiled patterns.
    Validates before deep-freeze, then freezes pattern-matched extras too.
    """

    __pattern_properties__: ClassVar[dict[re.Pattern, dict]] = {}

    @model_validator(mode='before')
    @classmethod
    def _validate_pattern_properties(cls, data: Any) -> Any:
        """
        Validate fields against patternProperties.

        Semantics:
        - Defined model fields skip pattern validation
        - Extra fields MUST match at least one pattern
        - If field matches multiple patterns, validate against ALL (AND)
        - oneOf requires exactly ONE branch to match
        """
        if not isinstance(data, dict) or not cls.__pattern_properties__:
            return data

        defined_fields = set(cls.model_fields.keys())
        errors = []

        for key, value in data.items():
            # Skip explicitly defined fields
            if key in defined_fields:
                continue

            # Find ALL matching patterns
            matching_patterns = [
                (pattern, schema)
                for pattern, schema in cls.__pattern_properties__.items()
                if pattern.match(key)
            ]

            if not matching_patterns:
                # No pattern matches - reject
                errors.append(InitErrorDetails(
                    type='extra_forbidden',
                    loc=(key,),
                    input=value,
                ))
            else:
                # Validate against ALL matching patterns (AND semantics)
                for pattern, schema in matching_patterns:
                    try:
                        _validate_pattern_value(key, value, schema)
                    except ValueError as e:
                        # Use 'value_error' with required 'error' key in ctx
                        errors.append(InitErrorDetails(
                            type='value_error',
                            loc=(key,),
                            input=value,
                            ctx={'error': str(e)}
                        ))

        if errors:
            raise ValidationError.from_exception_data(
                "PatternPropertiesValidation",
                errors,
                input_type='python'  # Explicitly specify input_type
            )

        return data

    def model_post_init(self, __context) -> None:
        """Deep-freeze declared fields AND pattern-matched extras."""
        # Freeze declared fields via parent
        super().model_post_init(__context)

        # Also freeze pattern-matched extra fields (stored in __pydantic_extra__)
        # Note: We must freeze extras AFTER parent's model_post_init
        if hasattr(self, '__pydantic_extra__') and self.__pydantic_extra__:
            # Create a new frozen dict - we can't modify the original due to frozen=True
            frozen_extras = {k: _deep_freeze(v) for k, v in self.__pydantic_extra__.items()}
            # Use object.__setattr__ to bypass frozen protection during init
            object.__setattr__(self, '__pydantic_extra__', frozen_extras)


def _validate_pattern_value(key: str, value: Any, schema: dict) -> None:
    """
    Validate value against patternProperty schema.

    Supports: type, string constraints, numeric constraints, oneOf, enum, arrays.
    """
    # Handle oneOf (exactly ONE must match)
    if "oneOf" in schema:
        matches = []
        errors = []

        for i, branch in enumerate(schema["oneOf"]):
            try:
                _validate_against_schema(key, value, branch)
                matches.append(i)
            except ValueError as e:
                errors.append(f"Branch {i}: {e}")

        if len(matches) != 1:
            if len(matches) == 0:
                branch_descriptions = [_describe_schema(b) for b in schema["oneOf"]]
                raise ValueError(
                    f"Value {value!r} for '{key}' doesn't match any oneOf branch.\\n"
                    f"Tried: {branch_descriptions}\\n"
                    f"Errors: {'; '.join(errors)}"
                )
            else:
                # Multiple matches - WRONG
                matched_descs = [
                    f"{i}: {_describe_schema(schema['oneOf'][i])}"
                    for i in matches
                ]
                raise ValueError(
                    f"Value {value!r} for '{key}' matches {len(matches)} oneOf branches "
                    f"(exactly 1 required).\\n"
                    f"Matched: {', '.join(matched_descs)}"
                )
        return

    # Single schema validation
    _validate_against_schema(key, value, schema)


def _validate_against_schema(key: str, value: Any, schema: dict) -> None:
    """Validate value against single schema definition."""
    # Type validation
    if "type" in schema:
        _validate_type(key, value, schema["type"])

    # String constraints
    if schema.get("type") == "string" and isinstance(value, str):
        if "minLength" in schema and len(value) < schema["minLength"]:
            raise ValueError(f"String '{key}' length {len(value)} < minLength {schema['minLength']}")
        if "maxLength" in schema and len(value) > schema["maxLength"]:
            raise ValueError(f"String '{key}' length {len(value)} > maxLength {schema['maxLength']}")
        if "pattern" in schema and not re.match(schema["pattern"], value):
            raise ValueError(f"String '{key}' doesn't match pattern {schema['pattern']}")

    # Numeric constraints
    if schema.get("type") in ("number", "integer") and isinstance(value, int | float):
        if "minimum" in schema and value < schema["minimum"]:
            raise ValueError(f"Number '{key}' {value} < minimum {schema['minimum']}")
        if "maximum" in schema and value > schema["maximum"]:
            raise ValueError(f"Number '{key}' {value} > maximum {schema['maximum']}")
        if "multipleOf" in schema:
            if value % schema["multipleOf"] != 0:
                raise ValueError(f"Number '{key}' {value} not multiple of {schema['multipleOf']}")

    # Enum validation
    if "enum" in schema and value not in schema["enum"]:
        raise ValueError(f"Value {value!r} for '{key}' not in enum: {schema['enum']}")

    # Array validation
    if schema.get("type") == "array" and isinstance(value, list):
        if "minItems" in schema and len(value) < schema["minItems"]:
            raise ValueError(f"Array '{key}' has {len(value)} items < minItems {schema['minItems']}")
        if "maxItems" in schema and len(value) > schema["maxItems"]:
            raise ValueError(f"Array '{key}' has {len(value)} items > maxItems {schema['maxItems']}")

        # Validate each item
        if "items" in schema:
            for i, item in enumerate(value):
                try:
                    _validate_against_schema(f"{key}[{i}]", item, schema["items"])
                except ValueError as e:
                    raise ValueError(f"Array item validation failed: {e}") from e


def _validate_type(key: str, value: Any, expected_type: str) -> None:
    """
    Validate value matches JSON Schema type.

    CRITICAL: Check boolean BEFORE integer (bool is subclass of int in Python).
    """
    # Boolean MUST be checked first
    if expected_type == 'boolean':
        if not isinstance(value, bool):
            raise ValueError(f"Field '{key}' must be boolean, got {type(value).__name__}")
        return

    if expected_type == 'integer':
        if isinstance(value, bool):
            raise ValueError(f"Field '{key}' must be integer, got boolean")
        if not isinstance(value, int):
            raise ValueError(f"Field '{key}' must be integer, got {type(value).__name__}")
        return

    # number also needs to exclude boolean
    if expected_type == 'number':
        if isinstance(value, bool):
            raise ValueError(f"Field '{key}' must be number, got boolean")
        if not isinstance(value, int | float):
            raise ValueError(f"Field '{key}' must be number, got {type(value).__name__}")
        return

    # Other types
    type_checks = {
        'string': str,
        'null': type(None),
        'array': list,
        'object': dict,
    }

    expected_py_type = type_checks.get(expected_type)
    if expected_py_type and not isinstance(value, expected_py_type):
        raise ValueError(f"Field '{key}' must be {expected_type}, got {type(value).__name__}")


def _describe_schema(schema: dict) -> str:
    if "type" in schema:
        t = schema["type"]
        constraints = []

        if t == "string" and "pattern" in schema:
            constraints.append(f"pattern={schema['pattern'][:20]}...")
        elif t in ("number", "integer"):
            if "minimum" in schema or "maximum" in schema:
                min_v = schema.get("minimum", "-∞")
                max_v = schema.get("maximum", "∞")
                constraints.append(f"range={min_v}..{max_v}")

        if constraints:
            return f"{t}({', '.join(constraints)})"
        return t

    if "enum" in schema:
        vals = schema["enum"][:3]
        return f"enum({vals}{'...' if len(schema['enum']) > 3 else ''})"

    return "schema"
'''


# Standalone validation functions for testing
# These are copies of the functions from the template above
# They can be imported and tested without FrozenModel dependency


def _validate_type(key: str, value, expected_type: str) -> None:
    # Boolean MUST be checked first (bool is subclass of int)
    if expected_type == "boolean":
        if not isinstance(value, bool):
            raise ValueError(f"Field '{key}' must be boolean, got {type(value).__name__}")
        return

    if expected_type == "integer":
        if isinstance(value, bool):
            raise ValueError(f"Field '{key}' must be integer, got boolean")
        if not isinstance(value, int):
            raise ValueError(f"Field '{key}' must be integer, got {type(value).__name__}")
        return

    # number also needs to exclude boolean
    if expected_type == "number":
        if isinstance(value, bool):
            raise ValueError(f"Field '{key}' must be number, got boolean")
        if not isinstance(value, int | float):
            raise ValueError(f"Field '{key}' must be number, got {type(value).__name__}")
        return

    type_checks = {
        "string": str,
        "null": type(None),
        "array": list,
        "object": dict,
    }

    expected_py_type = type_checks.get(expected_type)
    if expected_py_type and not isinstance(value, expected_py_type):
        raise ValueError(f"Field '{key}' must be {expected_type}, got {type(value).__name__}")


def _validate_against_schema(key: str, value, schema: dict) -> None:
    import re

    if "type" in schema:
        _validate_type(key, value, schema["type"])

    if schema.get("type") == "string" and isinstance(value, str):
        if "minLength" in schema and len(value) < schema["minLength"]:
            raise ValueError(f"String '{key}' length {len(value)} < minLength {schema['minLength']}")
        if "maxLength" in schema and len(value) > schema["maxLength"]:
            raise ValueError(f"String '{key}' length {len(value)} > maxLength {schema['maxLength']}")
        if "pattern" in schema and not re.match(schema["pattern"], value):
            raise ValueError(f"String '{key}' doesn't match pattern {schema['pattern']}")

    if schema.get("type") in ("number", "integer") and isinstance(value, int | float):
        if "minimum" in schema and value < schema["minimum"]:
            raise ValueError(f"Number '{key}' {value} < minimum {schema['minimum']}")
        if "maximum" in schema and value > schema["maximum"]:
            raise ValueError(f"Number '{key}' {value} > maximum {schema['maximum']}")
        if "multipleOf" in schema:
            if value % schema["multipleOf"] != 0:
                raise ValueError(f"Number '{key}' {value} not multiple of {schema['multipleOf']}")

    if "enum" in schema and value not in schema["enum"]:
        raise ValueError(f"Value {value!r} for '{key}' not in enum: {schema['enum']}")

    if schema.get("type") == "array" and isinstance(value, list):
        if "minItems" in schema and len(value) < schema["minItems"]:
            raise ValueError(f"Array '{key}' has {len(value)} items < minItems {schema['minItems']}")
        if "maxItems" in schema and len(value) > schema["maxItems"]:
            raise ValueError(f"Array '{key}' has {len(value)} items > maxItems {schema['maxItems']}")

        if "items" in schema:
            for i, item in enumerate(value):
                try:
                    _validate_against_schema(f"{key}[{i}]", item, schema["items"])
                except ValueError as e:
                    raise ValueError(f"Array item validation failed: {e}") from e


def _describe_schema(schema: dict) -> str:
    """Create human-readable schema description for errors."""
    if "type" in schema:
        t = schema["type"]
        constraints = []

        if t == "string" and "pattern" in schema:
            constraints.append(f"pattern={schema['pattern'][:20]}...")
        elif t in ("number", "integer"):
            if "minimum" in schema or "maximum" in schema:
                min_v = schema.get("minimum", "-∞")
                max_v = schema.get("maximum", "∞")
                constraints.append(f"range={min_v}..{max_v}")

        if constraints:
            return f"{t}({', '.join(constraints)})"
        return t

    if "enum" in schema:
        vals = schema["enum"][:3]
        return f"enum({vals}{'...' if len(schema['enum']) > 3 else ''})"

    return "schema"


def _validate_pattern_value(key: str, value, schema: dict) -> None:
    if "oneOf" in schema:
        matches = []
        errors = []

        for i, branch in enumerate(schema["oneOf"]):
            try:
                _validate_against_schema(key, value, branch)
                matches.append(i)
            except ValueError as e:
                errors.append(f"Branch {i}: {e}")

        if len(matches) != 1:
            if len(matches) == 0:
                branch_descriptions = [_describe_schema(b) for b in schema["oneOf"]]
                raise ValueError(
                    f"Value {value!r} for '{key}' doesn't match any oneOf branch.\n"
                    f"Tried: {branch_descriptions}\n"
                    f"Errors: {'; '.join(errors)}"
                )
            else:
                matched_descs = [f"{i}: {_describe_schema(schema['oneOf'][i])}" for i in matches]
                raise ValueError(
                    f"Value {value!r} for '{key}' matches {len(matches)} oneOf branches "
                    f"(exactly 1 required).\n"
                    f"Matched: {', '.join(matched_descs)}"
                )
        return

    _validate_against_schema(key, value, schema)
