# src/lithify/frozendict.py
from __future__ import annotations

from collections.abc import Hashable, Iterator, Mapping, MutableMapping
from typing import Any

try:
    from pydantic import GetCoreSchemaHandler
    from pydantic_core import core_schema

    PYDANTIC_AVAILABLE = True
except ImportError:
    PYDANTIC_AVAILABLE = False


def _freeze_for_hash(obj: Any) -> Hashable:
    if isinstance(obj, str | bytes | int | float | bool | type(None)):
        return obj
    if isinstance(obj, FrozenDict):
        return obj._canonical
    if isinstance(obj, Mapping):
        # Sort by frozen key to ensure deterministic ordering
        items = tuple(
            sorted(
                ((_freeze_for_hash(k), _freeze_for_hash(v)) for k, v in obj.items()),
                key=lambda kv: repr(kv[0]),  # Use repr for sorting mixed types
            )
        )
        return ("dict", items)
    if isinstance(obj, set | frozenset):
        return ("set", tuple(sorted((_freeze_for_hash(v) for v in obj), key=repr)))
    if isinstance(obj, list | tuple):
        return ("list", tuple(_freeze_for_hash(v) for v in obj))
    # Last resort: use repr as a stable text
    return ("repr", repr(obj))


class FrozenDict(Mapping):
    __slots__ = ("_data", "_hash", "_canonical")

    def __init__(self, data: MutableMapping | Mapping | None = None):
        self._data = dict(data or {})
        self._canonical = _freeze_for_hash(self._data)
        self._hash = hash(self._canonical)

    def __getitem__(self, key: Any) -> Any:
        return self._data[key]

    def __iter__(self) -> Iterator:
        return iter(self._data)

    def __len__(self) -> int:
        return len(self._data)

    def __hash__(self) -> int:
        return self._hash

    def __repr__(self) -> str:
        return f"FrozenDict({self._data!r})"

    def __str__(self) -> str:
        return str(self._data)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, FrozenDict):
            return self._data == other._data
        if isinstance(other, Mapping):
            return self._data == other
        return False

    if PYDANTIC_AVAILABLE:

        @classmethod
        def __get_pydantic_core_schema__(cls, source_type, handler: GetCoreSchemaHandler):
            dict_schema = core_schema.dict_schema(
                keys_schema=core_schema.any_schema(),
                values_schema=core_schema.any_schema(),
            )

            return core_schema.json_or_python_schema(
                json_schema=dict_schema,
                python_schema=core_schema.union_schema(
                    [
                        core_schema.is_instance_schema(cls),
                        core_schema.no_info_after_validator_function(lambda v: cls(v), dict_schema),
                    ]
                ),
                serialization=core_schema.plain_serializer_function_ser_schema(lambda v: dict(v), when_used="json"),
            )

        @classmethod
        def __get_pydantic_json_schema__(cls, schema, handler):
            return {"type": "object", "additionalProperties": True}


# Source code for embedding in generated modules
FROZENDICT_SOURCE = '''"""
FrozenDict - Immutable, hashable dictionary for deep-frozen models.

Auto-generated by Lithify. Do not edit directly.
"""

from __future__ import annotations
from typing import Iterator, Mapping, MutableMapping, Any, Hashable

def _freeze_for_hash(obj: Any) -> Hashable:
    """Convert to hashable form for canonical hashing."""
    if isinstance(obj, (str, bytes, int, float, bool, type(None))):
        return obj
    if isinstance(obj, FrozenDict):
        return obj._canonical
    if isinstance(obj, Mapping):
        items = tuple(sorted(
            ((_freeze_for_hash(k), _freeze_for_hash(v)) for k, v in obj.items()),
            key=lambda kv: repr(kv[0])
        ))
        return ("dict", items)
    if isinstance(obj, (set, frozenset)):
        return ("set", tuple(sorted((_freeze_for_hash(v) for v in obj), key=repr)))
    if isinstance(obj, (list, tuple)):
        return ("list", tuple(_freeze_for_hash(v) for v in obj))
    return ("repr", repr(obj))

class FrozenDict(Mapping):
    """Immutable dictionary that is hashable."""
    __slots__ = ("_data", "_hash", "_canonical")

    def __init__(self, data: MutableMapping | Mapping | None = None):
        self._data = dict(data or {})
        self._canonical = _freeze_for_hash(self._data)
        self._hash = hash(self._canonical)

    def __getitem__(self, key: Any) -> Any:
        return self._data[key]

    def __iter__(self) -> Iterator:
        return iter(self._data)

    def __len__(self) -> int:
        return len(self._data)

    def __hash__(self) -> int:
        return self._hash

    def __repr__(self) -> str:
        return f"FrozenDict({self._data!r})"

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, FrozenDict):
            return self._data == other._data
        if isinstance(other, Mapping):
            return self._data == other
        return False

    @classmethod
    def __get_pydantic_core_schema__(cls, source_type, handler):
        from pydantic_core import core_schema
        dict_schema = core_schema.dict_schema(
            keys_schema=core_schema.any_schema(),
            values_schema=core_schema.any_schema(),
        )
        return core_schema.json_or_python_schema(
            json_schema=dict_schema,
            python_schema=core_schema.union_schema([
                core_schema.is_instance_schema(cls),
                core_schema.no_info_after_validator_function(
                    lambda v: cls(v), dict_schema
                ),
            ]),
            serialization=core_schema.plain_serializer_function_ser_schema(
                lambda v: dict(v), when_used='json'
            ),
        )
'''
